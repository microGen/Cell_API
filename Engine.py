from numpy import inf
from math import ceil
from random import randint
from statistics import mean, median
from Helpers import MinMaxCoordinates, frange
import Factories


class Engine:
    def __init__(self, data_container):
        self._data_container = data_container
        self._cell_serial_number = 0
        self._cells = []
        self._gridpoint_ID = lambda x, y, z: str(f"{x:06}.{y:06}.{z:06}")
        pass

    def next_cell_serial_num(self):
        """Returns the first free serial number in list of cells"""

        return self._cell_serial_number

    def create_cell_structure(self, dims, init_cell_size, cell_properties):
        """Creates initial cell structure using arguments.
        dims: [x, y, z] - maximum dimensions, origin is [0, 0, 0]
        init_cell_size: [x, y, z] - initial cell size
        cell_properties: dictionary - properties transmitted by the cell data input file"""

        if len(self._cells) > 0:
            self._cells.clear()
        for x in frange(init_cell_size[0]/2, dims[0], init_cell_size[0], 8):
            for y in frange(init_cell_size[1]/2, dims[1], init_cell_size[1], 8):
                for z in frange(init_cell_size[2]/2, dims[2], init_cell_size[2], 8):
                    cell = Factories.CELL(self._cell_serial_number, [x, y, z], init_cell_size, cell_properties, False)
                    self._cells.append(cell)
                    self._cell_serial_number += 1
        return self._cells

    def get_cells(self, *ID):
        """Returns list of cells if no ID is given, else returns cell of given ID"""

        if not ID:
            return self._cells
        else:
            ID = ID[0]
            for cell in self._cells:
                if cell.ID() == ID:
                    return cell
                else:
                    print('No cell of ID exists')


    def apply_rules(self, cell, rules, prop_options, calc):
        """Applies rules from rulebook to determine whether a cells properties are within specifications.
        cell: current cell to be examined
        rules: list of rules to apply for examination of cell
        prop_options: list of options of the same length as rules to set whether min/max/mean/median of applicable
            grid data is to be used as input for the rule. Inputs: 'min', 'max', 'amn', 'med'
        calc: optional calculator. If a property is not directly supplied by cell data, a calculator can be applied for
            necessary calculations. Must be a list of the same length as rules. If no calculator is needed, the list
            must be 0"""

        # Handles choice of options for extraction of grid point properties.
        # Supported options are min, max, arithmetic mean (amn), median (med)
        def calc_prop_opt(properties, option):
            def prop_min(props):
                return min(props)
            def prop_max(props):
                return max(props)
            def prop_amn(props):
                return mean(props)
            def prop_med(props):
                return median(props)
            option_list = {'min': prop_min, 'max': prop_max, 'amn': prop_amn, 'med': prop_med}
            func = option_list.get(option)
            return func(properties)

        # Get grid points with coordinates within - or if not available, closest to - cell
        gridpoints = self._get_gridpoints(cell)
        rule_results = []
        for i in range(len(rules)):
            # Grid points should only get resource lists from rules as they must already contain the data that the rule
            # compares the cell to.
            rule_resources_grid = rules[i].get_resources_grid()
            #self.gridpoint_gradient(gridpoints, rule_resources_grid)
            rule_resources_cell = rules[i].get_resources_cell()

            # Choose how to get resource data from cell. If property calculator exists for rule, the resource list is
            # generated by calling its resource getter method. The cell's properties are passed to the calculator, which
            # generates the final property to be compared with grid data. Otherwise, cell properties are pulled by
            # calling the rule's getter.
            if calc[i] != 0:
                calc_resources = calc[i].get_resources_cell()
                cell_properties = {cr: cell.properties(cr) for cr in calc_resources}
                cell_resources = calc[i].calc(cell_properties)
            else:
                calc_resources = rule_resources_cell
                cell_resources = {cr: cell.properties(cr) for cr in calc_resources}

            # Get property list from the grid...
            grid_resource_list = []
            for grid_point in gridpoints:
                grid_resource = {rr: grid_point[rr] for rr in rule_resources_grid}
                grid_resource_list.append(grid_resource)
            # ...and extract the min / max / mean / median value from list
            grid_resources = {}
            for resource in rule_resources_grid:
                grid_data = [gr[resource] for gr in grid_resource_list]
                grid_resources.update({resource: calc_prop_opt(grid_data, prop_options[i])})
            rule_results.append(rules[i].apply(grid_resources, cell_resources))
            #print('Grid resources: ', grid_resources, ' Cell resources: ', cell_resources)

        return rule_results

    def gridpoint_gradient(self, cell, rule, *sample_width):
        """Returns a list of gradients in X/Y/Z direction for passed gridpoints. If multiple gridpoints are passed,
        the central one serves as a basis for gradient calculation. Step width sets the offset of sample points.
        Gradient is calculated from 3 sample points: center and center +- sample_width, averaged. If sample width is not
        set, it reverts to default of 1"""

        gridpoints = self._get_gridpoints(cell)
        properties = [p for p in rule.get_resources_grid()]
        orientation = [o for o in rule.get_orientation()]

        if sample_width:
            sample_width = sample_width[0]
        else:
            sample_width = 1
        min_index = self._data_container.get_min_index
        max_index = self._data_container.get_max_index
        # limit the lower and upper indices for the gradient to the grid indices
        limit_lower = lambda cp, sw, ax: cp-sw if (cp-sw >= min_index(ax)) else min_index(ax)
        limit_upper = lambda cp, sw, ax: cp+sw if (cp+sw <= max_index(ax)) else max_index(ax)

        # list gridpoint indices...
        gridpoint_indices = []
        for gp in gridpoints:
            gridpoint_indices.append(gp['index'])
        # ...and extract the median index...
        mid_gp_index = ceil(len(gridpoint_indices) / 2) - 1
        # ...to get the median gridpoint ID
        gradient_base = gridpoint_indices[mid_gp_index]
        # gradient_base_ID = self._gridpoint_ID(*list(gradient_base.values()))

        gradient = []
        for i in range(len(properties)):
            p = properties[i]
            o = orientation[i]
            gradient_list = []
            for axis, index in gradient_base.items():
                # gradient for current axis
                gradient_axis = gradient_base
                # get the lower gridpoint on current axis
                index_lower = limit_lower(index, sample_width, axis)
                gradient_axis[axis] = index_lower
                gradient_lower_ID = self._gridpoint_ID(*list(gradient_axis.values()))
                gridpoint_lower = self._data_container.get_gridpoint_by_ID(gradient_lower_ID)
                # get the upper gridpoint on current axis
                index_upper = limit_upper(index, sample_width, axis)
                gradient_axis[axis] = index_upper
                gradient_upper_ID = self._gridpoint_ID(*list(gradient_axis.values()))
                gridpoint_upper = self._data_container.get_gridpoint_by_ID(gradient_upper_ID)
                # assemble list of property gradients for current axis
                gradient_item = (gridpoint_upper[p] - gridpoint_lower[p]) / 2
                gradient_list.append(gradient_item)
            gradient.append([gradient_list, o])
        return gradient

    def _get_gridpoints(self, cell):
        """Returns a list of gridpoints that either are located in the space occupied by the passed cell or
        - if no gridpoint is found within the cell's bounds, the closest gridpoint. Return data type is always list."""
        cell_minmax = MinMaxCoordinates.calc(cell.properties('location'), cell.properties('dimensions'))
        return self._data_container.get_gridpoints(cell_minmax)

    def split_cell(self, cell, rule_result, property_gradient):
        """If command is true, cell is split along or across gradient, depending on the rule setting. In order to split
        the cell, core properties are extracted and used as base for the new cells."""

        gradient = property_gradient[0]
        orientation = property_gradient[1]

        if rule_result == True:
            # convert cell to final cell
            cell.set_final()
            return cell
        else:
            # split cell along / across gradient
            split_axis = self._create_split_plane(cell.properties('dimensions'), gradient, orientation, 'axis', True)
            # get all necessary data to create sub cells
            cell_ext_data = cell.ext_properties()
            cell_loc = cell.geometry('location')
            cell_dims = cell.geometry('dimensions')
            cell_id = cell.ID()
            # calculate dimensions of sub cells
            new_dims = cell_dims.copy()
            new_dims[split_axis] /= 2
            offset = new_dims[split_axis] / 2
            # calculate locations for sub cells
            new_loc_0 = cell_loc.copy()
            new_loc_0[split_axis] -= offset
            new_loc_1 = cell_loc.copy()
            new_loc_1[split_axis] += offset
            # create sub cells
            cell_n0 = Factories.CELL(cell_id, new_loc_0, new_dims, cell_ext_data, False)
            cell_n1 = Factories.CELL(self._cell_serial_number, new_loc_1, new_dims, cell_ext_data, False)
            self._cell_serial_number += 1
            self._cells[cell_id] = cell_n0
            self._cells.append(cell_n1)
            return [cell_n0, cell_n1]

    def _create_split_plane(self, cell_dimensions, gradient, orientation, return_format, ortho):
        """Finds greatest or smallest gradient according to orientation settings and builds a plane perpendicular to
        gradient axis. If argument ortho is true and the cell would be split across the smallest dimension, the next
        greatest/smallest gradient is used if both of the other cell dimensions are equal. Else, the split plane is
        built across the greatest dimension."""

        build_plane = lambda grad_index: list(filter(lambda axis: axis != grad_index, range(3)))

        gradient_index = self._find_index(gradient, orientation)
        plane = build_plane(gradient_index)

        if ortho:
            gradient_index = self._make_orthotropic(cell_dimensions, plane, gradient, gradient_index)
            plane = build_plane(gradient_index)

        '''
        plane_dims = list(map(lambda axis: cell_dimensions[axis], plane))

        if cell_dimensions[gradient_index] <= min(plane_dims):
            if plane_dims[0] == plane_dims[1]:
                # get next greatest gradient if both other axis' of cell are equal
                gradient_index_max = find_index(gradient, 'orthogonal')
                gradient_index_min = find_index(gradient, 'parallel')
                med_axis = lambda axis: axis != gradient_index_min and axis != gradient_index_max
                gradient_index = list(filter(med_axis, range(3)))[0]
            else:
                # get greatest dimension of cell, as else, a very slender cell will be generated
                gradient_index = cell_dimensions.index(max(cell_dimensions))
            plane = build_plane(gradient_index)
        '''
        # either return axis across which to split cell or return split plane
        return_format = return_format.lower()
        if return_format == 'axis':
            return gradient_index
        elif return_format == 'plane':
            return plane
        else:
            # future development?
            pass

    def _make_orthotropic(self, cell_dims, proto_plane, grad, grad_index):
        """Returns a split plane that splits the cell across the greatest dimension if split plane was built across a
        lesser dimension. Else returns the passed split plane. Attempts to create a cell structure that does not stray
        too much from orthotropic geometric properties."""

        plane_dims = list(map(lambda axis: cell_dims[axis], proto_plane))

        if cell_dims[grad_index] <= min(plane_dims):
            if plane_dims[0] == plane_dims[1]:
                # get next greatest gradient if both other axis' of cell are equal
                grad_index_max = self._find_index(grad, 'orthogonal')
                grad_index_min = self._find_index(grad, 'parallel')
                med_axis = lambda axis: axis != grad_index_min and axis != grad_index_max
                grad_index = list(filter(med_axis, range(3)))[0]
            else:
                # get greatest dimension of cell, as else, a very slender cell might be generated
                grad_index = cell_dims.index(max(cell_dims))
        return grad_index

    def _find_index(self, coord_sys, direction):
        """Choose split axis according to orientation given by rules"""
        cs = [abs(axis) for axis in coord_sys]
        if direction == 'orthogonal':
            # Split across gradient
            index = cs.index(max(cs))
        elif direction == 'parallel':
            # Split along gradient
            index = cs.index(min(cs))
        else:
            # If no orientation of split available, randomly choose an axis
            index = randint(0, 3)
        return index