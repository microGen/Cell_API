from numpy import inf
from math import ceil
from statistics import mean, median
import Factories
from Helpers import MinMaxCoordinates

class Arbiter:
    def __init__(self, data_container, *args):
        self.__data_container = data_container
        self.__cell_serial_number = 0
        self.__gridpoint_ID = lambda x, y, z: str(f"{x:06}.{y:06}.{z:06}")
        pass


    def create_cell_structure(self, dims, init_cell_size, cell_properties):
        """Creates initial cell structure using arguments.
        dims: [x, y, z] - maximum dimensions, origin is [0, 0, 0]
        init_cell_size: [x, y, z] - initial cell size
        cell_properties: dictionary - properties transmitted by the cell data input file"""

        cells = []
        for x in range(0, dims[0]+1, init_cell_size[0]):
            for y in range(0, dims[1]+1, init_cell_size[1]):
                for z in range(0, dims[2]+1, init_cell_size[2]):
                    cell = Factories.CELL(self.__cell_serial_number, [x, y, z], init_cell_size, cell_properties, False)
                    cells.append(cell)
                    self.__cell_serial_number += 1
        return cells

    ####################################################################################################################


    def apply_rules(self, cell, rules, prop_options, calc):
        """Applies rules from rulebook to determine whether a cells properties are within specifications.
        cell: current cell to be examined
        rules: list of rules to apply for examination of cell
        prop_options: list of options of the same length as rules to set whether min/max/mean/median of applicable
            grid data is to be used as input for the rule. Inputs: 'min', 'max', 'amn', 'med'
        calc: optional calculator. If a property is not directly supplied by cell data, a calculator can be applied for
            necessary calculations. Must be a list of the same length as rules. If no calculator is needed, the list
            must be 0"""

        # Handles choice of options for extraction of grid point properties.
        # Supported options are min, max, arithmetic mean (amn), median (med)
        def calc_prop_opt(properties, option):
            def prop_min(props):
                return min(props)
            def prop_max(props):
                return max(props)
            def prop_amn(props):
                return mean(props)
            def prop_med(props):
                return median(props)
            option_list = {'min': prop_min, 'max': prop_max, 'amn': prop_amn, 'med': prop_med}
            func = option_list.get(option)
            return func(properties)

        # Get grid points with coordinates within - or if not available, closest to - cell
        cell_minmax = MinMaxCoordinates.calc(cell.properties('location'), cell.properties('dimensions'))
        grid_points = self.__data_container.get_gridpoints(cell_minmax)
        #gradient = self.gridpoint_gradient(grid_points)

        rule_results = []
        for i in range(len(rules)):
            # Grid points should only get resource lists from rules as they must already contain the data that the rule
            # compares the cell to.
            rule_resources_grid = rules[i].get_resources_grid()
            self.gridpoint_gradient(grid_points, rule_resources_grid)
            rule_resources_cell = rules[i].get_resources_cell()

            # Choose how to get resource data from cell. If property calculator exists for rule, the resource list is
            # generated by calling its resource getter method. The cell's properties are passed to the calculator, which
            # generates the final property to be compared with grid data. Otherwise, cell properties are pulled by
            # calling the rule's getter.
            if calc[i] != 0:
                calc_resources = calc[i].get_resources_cell()
                cell_properties = {cr: cell.properties(cr) for cr in calc_resources}
                cell_resources = calc[i].calc(cell_properties)
            else:
                calc_resources = rule_resources_cell
                cell_resources = {cr: cell.properties(cr) for cr in calc_resources}

            # Get property list from the grid...
            grid_resource_list = []
            for grid_point in grid_points:
                grid_resource = {rr: grid_point[rr] for rr in rule_resources_grid}
                grid_resource_list.append(grid_resource)
            # ...and extract the min / max / mean / median value from list
            grid_resources = {}
            for resource in rule_resources_grid:
                grid_data = [gr[resource] for gr in grid_resource_list]
                grid_resources.update({resource: calc_prop_opt(grid_data, prop_options[i])})
            rule_results.append(rules[i].apply(grid_resources, cell_resources))
            #print('Grid resources: ', grid_resources, ' Cell resources: ', cell_resources)

        return rule_results

    ####################################################################################################################

    def gridpoint_gradient(self, gridpoints, properties, *sample_width):
        """Returns a list of gradients in X/Y/Z direction for passed gridpoints. If multiple gridpoints are passed,
        the central one serves as a basis for gradient calculation. Step width sets the offset of sample points.
        Gradient is calculated from 3 sample points: center and center +- sample_width, averaged. If sample width is not
        set, it reverts to default of 1"""
        if sample_width:
            sample_width = sample_width[0]
        else:
            sample_width = 1
        min_index = self.__data_container.get_min_index
        max_index = self.__data_container.get_max_index

        limit_lower = lambda cp, sw, ax: cp-sw if (cp-sw >= min_index(ax)) else min_index(ax)
        limit_upper = lambda cp, sw, ax: cp+sw if (cp+sw <= max_index(ax)) else max_index(ax)

        # list gridpoint indices...
        gridpoint_indices = []
        for gp in gridpoints:
            gridpoint_indices.append(gp['index'])
        # ...and extract the median index...
        mid_gp_index = ceil(len(gridpoint_indices) / 2) - 1
        # ...to get the median gridpoint ID
        gradient_base = gridpoint_indices[mid_gp_index]
        gradient_base_ID = self.__gridpoint_ID(*list(gradient_base.values()))

        gradient = []
        for axis, index in gradient_base.items():
            # gradient for current axis
            gradient_axis = gradient_base
            # get the lower gridpoint on current axis
            index_lower = limit_lower(index, sample_width, axis)
            gradient_axis[axis] = index_lower
            gradient_lower_ID = self.__gridpoint_ID(*list(gradient_axis.values()))
            gridpoint_lower = self.__data_container.get_gridpoint_by_ID(gradient_lower_ID)
            # get the upper gridpoint on current axis
            index_upper = limit_upper(index, sample_width, axis)
            gradient_axis[axis] = index_upper
            gradient_upper_ID = self.__gridpoint_ID(*list(gradient_axis.values()))
            gridpoint_upper = self.__data_container.get_gridpoint_by_ID(gradient_upper_ID)
            print('axis: ', axis, ' lower ID: ', gradient_lower_ID, ' base ID: ', gradient_base_ID, ' upper ID: ', gradient_upper_ID)
            # assemble list of property gradients for current axis
            gradient_list = []
            for p in properties:
                gradient_list.append((gridpoint_upper[p] - gridpoint_lower[p]) / 2)
            gradient.append(gradient_list)
        print('gradient: ', gradient)
        return gradient

    ####################################################################################################################


    def split_cell(self, axis, cell):
        pass
